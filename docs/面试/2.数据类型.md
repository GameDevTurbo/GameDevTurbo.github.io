引用类型，值类型，装箱拆箱， GC



**引用类型，值类型**



常用的值类型

结构体、枚举、整数型、浮点型、布尔型等

常用的引用类型

用户定义的类、数组、接口、委托，字符串



引用类型的对象将会在堆上分配内存；

值类型总是分配在它声明的地方，做为局部变量时，存储在栈上；类对象的字段时，则跟随此类存储在堆中。



**装箱拆箱**

**装箱** 就是把“值类型”转换成“引用类型”；

**拆箱** 就是把“引用类型”转换成“值类型”；



为什么说频繁的装箱拆箱会引起GC;

因为装箱的过程就是生产一个新的对象到堆中，把值放在这个对象的内存空间里面。

拆箱的时候才会从堆中把值复制到栈中（相当于新建）。

这个时候堆中的对象也不再需要了，相当于多了一个待回收的内存空间；

其次是拆箱的时候，需要把对象还原成原本的类型，也会涉及到一个类型的检查，最后会新建一个新的值类型到栈中。



举个例子：
假设一个事件 使用的不确定的Object类型去设计为通用的参数；
这个时候，只要触发事件，且参数为值类型的时候，就会先进行装箱操作，生成一个新对象到堆之中。
随后，在多个监听事件的地方，会单独进行拆箱，每次拆箱，则会新建一个新的值类型到堆栈之中。
如果是明确的类型进行传递，则只会存在一个值类型在堆栈之中，而一旦触发了装箱拆箱，则会提高内存的占用。



**GC**

GC只会回收 **堆** 的内存 ，而 值类型在 **栈** 中的使用完后马上就会给释放，并不需要 GC 进行处理；

堆中的没有被引用或者null的对象才会被回收；

静态的变量也不会被回收；



垃圾回收器具有以下优点：

- 不必手动释放内存。
- 提高内存的有效利用率。



非托管堆的需要手动处理

常见的操作：文件流，数据库的连接，

对于包含非托管资源的类，最好使用 using 语句块来创建该类的对象，并在结束时自动调用 Dispose() 方法来释放资源，以确保及时释放非托管资源。





