# Hello World

#### 简单案例

```glsl
#ifdef GL_ES
precision mediump float;
#endif

uniform float u_time;

void main() {
    gl_FragColor = vec4(1.0,0.0,1.0,1.0);
}
```



1. shader 语言 有一个 `main` 函数，会在最后返回颜色值。

2. 最终的像素颜色取决于预设的全局变量 `gl_FragColor`。

3. 有内建的**变量**（像`gl_FragColor`），**函数**和**数据类型**。

   - `vec4`（四分量浮点向量）
   - `vec3` （三分量浮点向量）和 `vec2` （二分量浮点向量）
   - `float`（单精度浮点型）， `int`（整型） 和 `bool`（布尔型）。
   
4. 如果我们仔细观察 `vec4` 类型，可以推测这四个变量分别响应红，绿，蓝和透明度通道。
   - 同时我们也可以看到这些变量是**归一化**的
     - 归一化：值从0到1
   - 之后我们会学习如何归一化变量，使得在变量间 **map**（映射）数值更加容易。
   
5. 预处理程序的宏指令 （编译宏）

   - 有了宏才可以 `#define` （定义）全局变量和进行一些基础的条件运算（通过使用 `#ifdef` 和 `#endif`）。
   - 所有的宏都以 `#` 开头。
   - 预编译会在编译前一刻发生，把所有的命令复制到 `#defines` 里，
     - 检查`#ifdef`  条件句是否已被定义
     - 检查`#ifndef` 条件句是否未定义
   - 在我们刚刚的“hello world!”的例子中，我们在第2行检查了 `GL_ES` 是否被定义，这个通常用在移动端或浏览器的编译中。

6. `float`类型在 shaders 中非常重要，**精度**非常重要。

   - 更低的精度会有更快的渲染速度，但是会以质量为代价。
   - 你可以选择每一个浮点值的精度。
   - 在第一行（`precision mediump float;`）我们就是设定了所有的浮点值都是 `中等精度`。
     - 也可以设为“低”（`precision lowp float;`）
     - 或者“高”（`precision highp float;`）

7. 最后可能也是最重要的细节是，GLSL 语言规范并不保证变量会被自动转换类别。

   - 比如有的地方需要使用 float 类型，但是你传入了 number 既符合 int 类型，就不会保证转换为 float 类型。

   - 以下代码可能不能正常运行

     ```glsl
     void main() {
         // 出错
         gl_FragColor = vec4(1,0,0,1);
     }
     ```
   
   - 如果你想要代码前后一致，不要之后花费大量时间 debug 的话，最好养成在 `float` 型数值里加一个 `.` 的好习惯。



#### 做点有趣的？

- 把单精度浮点值换成整型数值，猜猜你的显卡能不能容忍这个行为。

- 试试把第八行注释掉，不给函数赋任何像素的值。

- 尝试另外写个函数，返回某个颜色，然后在 `main()` 里面使用这个函数。给个提示，这个函数应该长这样：

  - ```glsl
    vec4 red(){
        return vec4(1.0,0.0,0.0,1.0);
    }
    ```

- 有很多种构造 `vec4` 类型的方式，试试看其他方式。下面就是其中一种方式：

  - ```glsl
    vec4 color = vec4(vec3(1.0,0.0,1.0),1.0);
    ```
