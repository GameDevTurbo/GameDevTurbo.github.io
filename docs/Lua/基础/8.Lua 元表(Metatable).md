# Lua 元表(Metatable)
> 什么是元表：
元表像是一个“操作指南”，里面包含了一系列操作的解决方案，例如__index方法就是定义了这个表在索引失败的情况下该怎么办。

#### 相关函数

###### setmetatable(table,metatable)
> 对指定 table 设置元表(metatable)，如果元表(metatable)中存在 __metatable 键值，setmetatable 会失败。
###### getmetatable(table)
> 返回对象的元表(metatable)。

###### 示例

> 对指定的表设置元表：

```lua
mytable = {}                          -- 普通表
mymetatable = {}                      -- 元表
setmetatable(mytable,mymetatable)     -- 把 mymetatable 设为 mytable 的元表
```

> 以上代码也可以直接写成一行：

```lua
mytable = setmetatable({},{})
```

> 返回对象元表

```lua
getmetatable(mytable)                 -- 这会返回 mymetatable
```

---
&nbsp;

#### __index 元方法

> 这是 metatable 最常用的键。

> 当你通过键来访问 table 的时候，如果这个键没有值，那么Lua就会寻找该table的metatable（假定有metatable）中的__index 键。如果__index包含一个表格，Lua会在表格中查找相应的键。

```lua
> other = { foo = 3 }
> t = setmetatable({}, { __index = other })
> t.foo
3
> t.bar
nil
```

> 如果__index包含一个函数的话，Lua就会调用那个函数，<b>table 和 键</b>会作为参数传递给函数。

> _index 元方法查看表中元素是否存在，如果不存在，返回结果为 nil；如果存在则由 __index 返回结果。

```lua
mytable = setmetatable({key1 = "value1"}, {
  __index = function(mytable, key)
    if key == "key2" then
      return "metatablevalue"
    else
      return nil
    end
  end
})

print(mytable.key1,mytable.key2)

// 执行结果
value1    metatablevalue
```

> 我们可以将以上代码简单写成：

```lua
mytable = setmetatable({key1 = "value1"}, { __index = { key2 = "metatablevalue" } })
print(mytable.key1,mytable.key2)
```


###### 总结
> Lua 查找一个表元素时的规则，其实就是如下 3 个步骤:
>-   1.在表中查找，如果找到，返回该元素，找不到则继续
>-    2.判断该表是否有元表，如果没有元表，返回 nil，有元表则继续。
>-    3.判断元表有没有 __index 方法，如果 __index 方法为 nil，则返回 nil；如果 __index 方法是一个表，则重复 1、2、3；如果 __index 方法是一个函数，则返回该函数的返回值。

###### 附加

>- 并非把表b设置为表a的元表，在a中查找a中没有但是b中有的元素c时，就会返回元素c;
>- 而是需要设置为元表的同时，设置为__index方法，才能在索引失败时正确的查找到索引的值。

```lua
father = {
	house=1
}
son = {
	car=1
}
setmetatable(son, father) --把son的metatable设置为father
print(son.house)

-- __index方法为nil，则返回nil
// 输出的结果是nil，但如果把代码改为

father = {
	house=1
}
father.__index = father -- 把father的__index方法指向自己
son = {
	car=1
}
setmetatable(son, father)
print(son.house)

// 输出的结果为1，符合预期
```

---
&nbsp;

#### __newindex 元方法

> __newindex 元方法用来对表更新，__index则用来对表访问 。

> 当你给表的一个缺少的索引赋值，解释器就会查找__newindex 元方法：如果存在则调用这个函数而不进行赋值操作。

###### 示例

> 以下实例中表设置了元方法 __newindex，在对新索引键（newkey）赋值时（mytable.newkey = "新值2"），会调用元方法，而不进行赋值。而如果对已存在的索引键（key1），则会进行赋值，而不调用元方法 __newindex。

```lua
mymetatable = {}
mytable = setmetatable({key1 = "value1"}, { __newindex = mymetatable })

print(mytable.key1)

mytable.newkey = "新值2"
print(mytable.newkey,mymetatable.newkey)

mytable.key1 = "新值1"
print(mytable.key1,mymetatable.key1)

// 执行结果
value1
nil    新值2
新值1    nil
```

###### 使用 rawset 从元表更新主表

```
mytable = setmetatable({key1 = "value1"}, {
    __newindex = function(mytable, key, value)
        rawset(mytable, key, "\""..value.."\"")
    end
})

mytable.key1 = "new value"
mytable.key2 = 4

print(mytable.key1,mytable.key2)

// 执行结果
new value    "4"
```

---
&nbsp;

#### 为表添加操作符

###### 示例

```lua
-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用
-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数
function table_maxn(t)
    local mn = 0
    for k, v in pairs(t) do
        if mn < k then
            mn = k
        end
    end
    return mn
end

-- 两表相加操作
mytable = setmetatable({ 1, 2, 3 }, {
  __add = function(mytable, newtable)
    for i = 1, table_maxn(newtable) do
      table.insert(mytable, table_maxn(mytable)+1,newtable[i])
    end
    return mytable
  end
})

secondtable = {4,5,6}

mytable = mytable + secondtable
        for k,v in ipairs(mytable) do
print(k,v)
end

// 执行结果
1    1
2    2
3    3
4    4
5    5
6    6
```

###### __add
> 对应的运算符 '+'.

###### __sub
> 对应的运算符 '-'.

###### __mul
> 对应的运算符 '*'.

###### __div
> 对应的运算符 '/'.

###### __mod
> 对应的运算符 '%'.

###### __unm
> 对应的运算符 '-'.

###### __concat
> 对应的运算符 '..'.

###### __eq
> 对应的运算符 '=='.

###### __lt
> 对应的运算符 '<'.

###### __le
> 对应的运算符 '<='.


---
&nbsp;

#### __call 元方法

```lua
-- 计算表中最大值，table.maxn在Lua5.2以上版本中已无法使用
-- 自定义计算表中最大键值函数 table_maxn，即计算表的元素个数
function table_maxn(t)
    local mn = 0
    for k, v in pairs(t) do
        if mn < k then
            mn = k
        end
    end
    return mn
end

-- 定义元方法__call
mytable = setmetatable({10}, {
  __call = function(mytable, newtable)
        sum = 0
        for i = 1, table_maxn(mytable) do
                sum = sum + mytable[i]
        end
    for i = 1, table_maxn(newtable) do
                sum = sum + newtable[i]
        end
        return sum
  end
})
newtable = {10,20,30}
print(mytable(newtable))

// 执行结果
70
```

---
&nbsp;

#### __tostring 元方法

```lua
mytable = setmetatable({ 10, 20, 30 }, {
  __tostring = function(mytable)
    sum = 0
    for k, v in pairs(mytable) do
                sum = sum + v
        end
    return "表所有元素的和为 " .. sum
  end
})
print(mytable)

// 执行结果
表所有元素的和为 60
```

---
&nbsp;